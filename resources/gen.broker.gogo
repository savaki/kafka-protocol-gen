// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}

import (
  "fmt"

  "{{ .Module }}/message"
)

// Client provides access to Kafka
type Broker struct {
  apiVersion apiVersion
  config     config
  conn       *Conn
}

// NewBroker a new Kafka Broker
func NewBroker(addr string, opts ...Option) (*Broker, error) {
  config := buildConfig(opts)
  conn, err := Connect(addr, opts...)
  if err != nil {
  	return nil, err
  }

  broker := &Broker{
    config: config,
    conn:   conn,
  }

  // negotiate usable api versions prior to returning broker
  //
  resp, err := broker.ApiVersions(message.ApiVersionsRequest{})
  if err != nil {
  	return nil, fmt.Errorf("unable to create broker: %w", err)
  }
  apiVersion, err := negotiateApiVersions(resp.ApiKeys)
  if err != nil {
    return nil, fmt.Errorf("unable to create broker: %w", err)
  }
  broker.apiVersion = apiVersion

  return broker, nil
}

// Close the connection to the broker
func (b *Broker) Close() error {
	return b.conn.Close()
}

{{- range .Messages }}
{{- if .Name | isRequest }}

// {{ .Name | baseName }} (apiKey: {{ .ApiKey }})
func (b *Broker) {{ .Name | baseName }}(req message.{{ .Name }}) (message.{{ .Name | baseName }}Response, error) {
  var resp message.{{ .Name | baseName }}Response
  err := b.conn.Do(
  	// encode request
    func(e *message.Encoder, correlationID int32) {
      hdr := message.RequestHeader{
        RequestApiKey:     message.Key{{ .Name | baseName }},
        RequestApiVersion: b.apiVersion.{{ .Name | baseName }},
        CorrelationId:     correlationID,
        ClientId:          b.config.clientID,
      }
      size := hdr.Size(2) + req.Size(b.apiVersion.{{ .Name | baseName }})
      e.PutInt32(size)
      hdr.Encode(e, 2)
      req.Encode(e, b.apiVersion.{{ .Name | baseName }})
    },
    // decode response
    func(d *message.Decoder) error {
      return (&resp).Decode(d, b.apiVersion.{{ .Name | baseName }})
    },
  )
  return resp, err
}
{{- end }}
{{- end }}

type MessageHandler func(*Message) error

type Subscription struct {
}

func (b *Broker) Subscribe(topics string, handler MessageHandler) (*Subscription, error) {
  return nil, nil
}

// apiVersion contains the negotiated versions for each api key
type apiVersion struct {
  {{- range .Messages }}
  {{- if .Name | isRequest }}
  {{ .Name | baseName }} int16
  {{- end }}
  {{- end }}
}

// negotiateApiVersions accepts the apiKeys from the broker and negotiates
// acceptable versions for each api based on the versions supported by
// this library.
func negotiateApiVersions(apiKeys []message.ApiVersionsResponseKey18) (apiVersion, error) {
  // Since this file is generated, there's no need to externalize the supported
  // versions elsewhere.  We can simply inline the values into the call to matchVersion
  var av apiVersion
  var err error
  for _, apiKey := range apiKeys {
    switch apiKey.ApiKey {
    {{- range .Messages }}
    {{- if .Name | isRequest }}
    case message.Key{{ .Name | baseName }}:
      av.{{ .Name | baseName }}, err = matchVersion(apiKey, {{ .ValidVersions.From }}, {{ .ValidVersions.To }})
      if err != nil {
        return apiVersion{}, err
      }
    {{- end }}
    {{- end }}
    }
  }
  return av, nil
}

// matchVersion determines which version of the api to use
func matchVersion(apiKey message.ApiVersionsResponseKey18, minVersion, maxVersion int16) (int16, error) {
  for version := apiKey.MaxVersion; version >= apiKey.MinVersion; version-- {
    if version := apiKey.MaxVersion; version >= minVersion && version <= maxVersion {
      return version, nil
    }
  }
  return 0, fmt.Errorf("unable to negotiate version for api key, %v", apiKey.ApiKey)
}
