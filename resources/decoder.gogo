// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}

import (
  "encoding/binary"
  "errors"
)

var (
  errInsufficientData = errors.New("insufficient data to decode packet")
  errNullString       = errors.New("null string")
  errVarIntOverflow   = errors.New("var int overflow")
)

// IsInsufficientDataError if the buffer has insufficient data to unmarshal
// the message
func IsInsufficientDataError(err error) bool {
  return errors.Is(err, errInsufficientData)
}

// Decoder implements a generic protocol decoder
type Decoder struct {
  buffer *RingBuffer
  data   []byte
  remain int
}

// NewDecoder returns a new Decoder
func NewDecoder(buffer *RingBuffer, size int) *Decoder {
  return &Decoder{
    buffer: buffer,
    data:   make([]byte, 1024*1024),
    remain: size,
  }
}

// remains ensures that the buffer contains at least n more bytes
func (d *Decoder) remains(n int) error {
  d.remain -= n
  if d.remain < 0 {
    return errInsufficientData
  }
  return nil
}

// ArrayLength reads the head of the buffer as an array length (int32)
func (d *Decoder) ArrayLength() (int, error) {
  n, err := d.Int32()
  if err != nil {
    return 0, err
  }
  return int(n), nil
}

// Bool returns the buffer head as a bool
func (d *Decoder) Bool() (bool, error) {
  if err := d.remains(1); err != nil {
    return false, err
  }
  d.buffer.ReadN(d.data, 1)
  b := d.data[0] == 1
  return b, nil
}

// Bytes returns the buffer head as a byte array
func (d *Decoder) Bytes() ([]byte, error) {
  n, err := d.Int32()
  if err != nil {
    return nil, err
  }
  length := int(n)

  if err := d.remains(length); err != nil {
    return nil, err
  }
  data := make([]byte, length)
  d.buffer.ReadN(data, length)
  return data, nil
}

// Int8 returns the buffer head as an int8
func (d *Decoder) Int8() (int8, error) {
  if err := d.remains(1); err != nil {
    return 0, err
  }
  d.buffer.ReadN(d.data, 1)
  v := int8(d.data[0])
  return v, nil
}

// Int16 returns the buffer head as an int16
func (d *Decoder) Int16() (int16, error) {
  if err := d.remains(2); err != nil {
    return 0, err
  }
  d.buffer.ReadN(d.data, 2)
  v := int16(binary.BigEndian.Uint16(d.data))
  return v, nil
}

// Int32 returns the buffer head as an int32
func (d *Decoder) Int32() (int32, error) {
  if err := d.remains(4); err != nil {
    return 0, err
  }
  d.buffer.ReadN(d.data, 4)
  v := int32(binary.BigEndian.Uint32(d.data))
  return v, nil
}

// Int32Array returns the buffer head as an []int32
func (d *Decoder) Int32Array() ([]int32, error) {
  n, err := d.ArrayLength()
  if err != nil {
    return nil, err
  }

  if n == -1 {
    return nil, nil
  }

  items := make([]int32, n)
  for i := 0; i < n; i++ {
    item, err := d.Int32()
    if err != nil {
      return nil, err
    }
    items[i] = item
  }

  return items, nil
}

// Int64 returns the buffer head as an int64
func (d *Decoder) Int64() (int64, error) {
  if err := d.remains(8); err != nil {
    return 0, err
  }
  d.buffer.ReadN(d.data, 8)
  v := int64(binary.BigEndian.Uint64(d.data))
  return v, nil
}

// Int64Array returns the buffer head as an []int64
func (d *Decoder) Int64Array() ([]int64, error) {
  n, err := d.ArrayLength()
  if err != nil {
    return nil, err
  }

  if n == -1 {
    return nil, nil
  }

  items := make([]int64, n)
  for i := 0; i < n; i++ {
    item, err := d.Int64()
    if err != nil {
      return nil, err
    }
    items[i] = item
  }

  return items, nil
}

// NullableString returns the buffer head as a *string
func (d *Decoder) NullableString() (*string, error) {
  s, err := d.String()
  if err != nil {
    if err == errNullString {
      return nil, nil
    }
    return nil, err
  }

  return &s, nil
}

// String returns the buffer head as a string
func (d *Decoder) String() (string, error) {
  n, err := d.Int16()
  if err != nil {
    return "", err
  }

  if n == -1 {
    return "", errNullString
  }

  length := int(n)
  if err := d.remains(length); err != nil {
    return "", err
  }

  d.buffer.ReadN(d.data, length)
  s := string(d.data[0:length])
  return s, nil
}

// StringArray returns the buffer head as a []string
func (d *Decoder) StringArray() ([]string, error) {
  n, err := d.ArrayLength()
  if err != nil {
    return nil, err
  }

  if n == -1 {
    return nil, nil
  }

  items := make([]string, n)
  for i := 0; i < n; i++ {
    item, err := d.String()
    if err != nil {
      return nil, err
    }
    items[i] = item
  }

  return items, nil
}

// VarInt returns the buffer head as an int64
func (d *Decoder) VarInt() (int64, error) {
  var data [12]byte
  var sz int

  for i := 0; i < 12; i++ {
    d.buffer.ReadN(d.data, 1)
    data[i] = d.data[0]
    sz++
    if data[i]&0x8 == 0 {
      break
    }
  }

  tmp, n := binary.Varint(data[0:sz])
  switch n {
  case 0:
    return 0, errInsufficientData

  case -1:
    return 0, errVarIntOverflow

  default:
    return tmp, nil
  }
}
