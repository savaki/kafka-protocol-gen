// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}

import (
  "fmt"
  "net"
)

type config struct {
  brokers  []string
  clientID string
  dialFunc func(network, addr string) (net.Conn, error)
}

// Client provides access to Kafka
type Broker struct {
  apiVersion apiVersion
  config     config
  conn       *connection
}

// Option provides functional options to Client
type Option func(*config)

// buildConfig builds config from provided options
func buildConfig(opts []Option) config {
  c := config{
  	clientID: "{{ .Module }}",
  	dialFunc: net.Dial,
	}

  for _, opt := range opts {
    opt(&c)
  }

  return c
}

// New a new Kafka Broker
func New(addr string, opts ...Option) (*Broker, error) {
  config := buildConfig(opts)
  conn, err := connect(addr, config)
  if err != nil {
  	return nil, err
  }

  broker := &Broker{
    config: config,
    conn:   conn,
  }

  // negotiate usable api versions prior to returning broker
  //
  resp, err := broker.ApiVersions(ApiVersionsRequest{})
  if err != nil {
  	return nil, fmt.Errorf("unable to create broker: %w", err)
  }
  apiVersion, err := negotiateApiVersions(resp.ApiKeys)
  if err != nil {
    return nil, fmt.Errorf("unable to create broker: %w", err)
  }
  broker.apiVersion = apiVersion

  return broker, nil
}

// Close the connection to the broker
func (b *Broker) Close() error {
	return b.conn.Close()
}

{{- range .Messages }}
{{- if .Name | isRequest }}

// {{ .Name | baseName }} (apiKey: {{ .ApiKey }})
func (b *Broker) {{ .Name | baseName }}(req {{ .Name }}) ({{ .Name | baseName }}Response, error) {
  var resp {{ .Name | baseName }}Response
  err := b.conn.write(
  	// encode request
    func(e *encoder, correlationID int32) {
      hdr := RequestHeader{
        RequestApiKey:     key{{ .Name | baseName }},
        RequestApiVersion: b.apiVersion.{{ .Name | baseName }},
        CorrelationId:     correlationID,
        ClientId:          b.config.clientID,
      }
      size := hdr.size(2) + req.size(b.apiVersion.{{ .Name | baseName }})
      e.PutInt32(size)
      hdr.encode(e, 2)
      req.encode(e, b.apiVersion.{{ .Name | baseName }})
    },
    // decode response
    func(d *decoder) error {
      return (&resp).decode(d, b.apiVersion.{{ .Name | baseName }})
    },
  )
  return resp, err
}
{{- end }}
{{- end }}

// Message defines the standard consumer and producer message
type Message struct {
  Topic string
  Key   []byte
  Value []byte
}

type MessageHandler func(*Message) error

type Subscription struct {
}

func (b *Broker) Subscribe(topics string, handler MessageHandler) (*Subscription, error) {
  return nil, nil
}