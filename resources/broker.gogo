// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}

import (
  "fmt"
  "net"

  "{{ .Module }}/protocol"
)

const defaultClientID = "{{ .Module }}"

type config struct {
  brokers  []string
  clientID string
  dialFunc func(network, addr string) (net.Conn, error)
}

// Client provides access to Kafka
type Broker struct {
  apiVersion apiVersion
  config     config
  conn       *protocol.Conn
}

// Option provides functional options to Client
type Option func(*config)

// WithClientID allows kafka client id to be specified
func WithClientID(id string) Option {
  return func(c *config) {
    if id == "" {
    	c.clientID = defaultClientID
    	return
    }
    c.clientID = id
  }
}

// buildConfig builds config from provided options
func buildConfig(opts []Option) config {
  c := config{
    clientID: defaultClientID,
    dialFunc: net.Dial,
  }

  for _, opt := range opts {
    opt(&c)
  }

  return c
}

// NewBroker a new Kafka Broker
func NewBroker(addr string, opts ...Option) (*Broker, error) {
  config := buildConfig(opts)
  conn, err := protocol.Connect(addr)
  if err != nil {
  	return nil, err
  }

  broker := &Broker{
    config: config,
    conn:   conn,
  }

  // negotiate usable api versions prior to returning broker
  //
  resp, err := broker.ApiVersions(ApiVersionsRequest{})
  if err != nil {
  	return nil, fmt.Errorf("unable to create broker: %w", err)
  }
  apiVersion, err := negotiateApiVersions(resp.ApiKeys)
  if err != nil {
    return nil, fmt.Errorf("unable to create broker: %w", err)
  }
  broker.apiVersion = apiVersion

  return broker, nil
}

// Close the connection to the broker
func (b *Broker) Close() error {
	return b.conn.Close()
}

{{- range .Messages }}
{{- if .Name | isRequest }}

// {{ .Name | baseName }} (apiKey: {{ .ApiKey }})
func (b *Broker) {{ .Name | baseName }}(req {{ .Name }}) ({{ .Name | baseName }}Response, error) {
  var resp {{ .Name | baseName }}Response
  err := b.conn.Write(
  	// encode request
    func(e *protocol.Encoder, correlationID int32) {
      hdr := RequestHeader{
        RequestApiKey:     apikey.{{ .Name | baseName }},
        RequestApiVersion: b.apiVersion.{{ .Name | baseName }},
        CorrelationId:     correlationID,
        ClientId:          b.config.clientID,
      }
      size := hdr.size(2) + req.size(b.apiVersion.{{ .Name | baseName }})
      e.PutInt32(size)
      hdr.Encode(e, 2)
      req.Encode(e, b.apiVersion.{{ .Name | baseName }})
    },
    // decode response
    func(d *protocol.Decoder) error {
      return (&resp).Decode(d, b.apiVersion.{{ .Name | baseName }})
    },
  )
  return resp, err
}
{{- end }}
{{- end }}

// Message defines the standard consumer and producer message
type Message struct {
  Topic string
  Key   []byte
  Value []byte
}

type MessageHandler func(*Message) error

type Subscription struct {
}

func (b *Broker) Subscribe(topics string, handler MessageHandler) (*Subscription, error) {
  return nil, nil
}