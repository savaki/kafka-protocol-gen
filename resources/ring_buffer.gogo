// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}

import (
	"sync/atomic"
)

type RingBuffer struct {
	data      []byte
	start     int32
	end       int32
	lock      chan struct{}
	lockState int32
	size      int32
}

func NewRingBuffer(size int) *RingBuffer {
	return &RingBuffer{
		data: make([]byte, size),
		lock: make(chan struct{}),
		size: int32(size),
	}
}

func (r *RingBuffer) WriteN(data []byte, n int) {
	var (
		pos   = atomic.LoadInt32(&r.end)   // end of data
		start = atomic.LoadInt32(&r.start) // start of data
		wrote int                          // bytes written since last lock
	)

	for i := 0; i < n; i++ {
		r.data[pos] = data[i]
		pos++
		if pos == r.size {
			pos = 0
		}

		// whenever pos catches up to the starting position, wait for
		// additional bytes to be written before continuing
		if pos == start {
			// important to store pos prior to reading from lockMux
			atomic.StoreInt32(&r.end, pos)

			// release the read goroutine if its locked on us
			if atomic.CompareAndSwapInt32(&r.lockState, 1, 0) {
				wrote = i
				<-r.lock
			}

			// lock this goroutine and wait for the read goroutine to unlock us
			if atomic.CompareAndSwapInt32(&r.lockState, 0, 1) {
				r.lock <- struct{}{}
				start = atomic.LoadInt32(&r.start)
			}
		}
	}

	atomic.StoreInt32(&r.end, pos)

	// if at least one byte has been written since the last time r.lock
	// was cleared, check to see if it needs to be cleared again
	if n > wrote+1 {
		if atomic.CompareAndSwapInt32(&r.lockState, 1, 0) {
			<-r.lock
		}
	}
}

func (r *RingBuffer) ReadN(data []byte, n int) {
	var (
		pos  = atomic.LoadInt32(&r.start)
		end  = atomic.LoadInt32(&r.end)
		read = 0
	)

	for i := 0; i < n; i++ {
		if pos == end {
			if read > 0 {
				atomic.StoreInt32(&r.start, pos)
				if atomic.CompareAndSwapInt32(&r.lockState, 1, 0) {
					<-r.lock
					read = 0
				}
			}
			if atomic.CompareAndSwapInt32(&r.lockState, 0, 1) {
				r.lock <- struct{}{}
				end = atomic.LoadInt32(&r.end)
			}
		}

		data[i] = r.data[pos]
		pos++
		if pos == r.size {
			pos = 0
		}
		read++
	}

	atomic.StoreInt32(&r.start, pos)
	if read > 0 {
		if atomic.CompareAndSwapInt32(&r.lockState, 1, 0) {
			<-r.lock
		}
	}
}
