// Code generated by kafka-protocol-gen. DO NOT EDIT.
//
// Copyright 2019 Matt Ho
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package {{ .Package }}

import (
  "bufio"
  "context"
  "fmt"
  "net"
  "sync"
  "sync/atomic"
)

type connection struct {
  cancel      context.CancelFunc
  ch          chan request
  doneMessage chan struct{}
  doneRead    chan struct{}
  encoder     *encoder
  err         error
  id          int32
  raw         net.Conn

  writeLock sync.Mutex
  readLock  sync.Mutex
  requests  map[int32]request
}

type request struct {
  decode func(*decoder) error
  reply  chan error
}

func connect(addr string, config config) (*connection, error) {
  raw, err := config.dialFunc("tcp", addr)
  if err != nil {
    return nil, fmt.Errorf("failed to dial broker, %v: %w", addr, err)
  }

  var (
    ctx, cancel = context.WithCancel(context.Background())
    rb          = newRingBuffer(5e6)
    ch          = make(chan request, 32)
    e           = newEncoder(bufio.NewWriter(raw))
  )

  c := &connection{
    cancel:      cancel,
    ch:          ch,
    doneMessage: make(chan struct{}),
    doneRead:    make(chan struct{}),
    encoder:     e,
    raw:         raw,
    requests:    map[int32]request{},
  }
  go c.readLoop(ctx, rb, raw)
  go c.messageLoop(ctx, rb, ch)

  return c, nil
}

func (c *connection) readLoop(ctx context.Context, rb *ringBuffer, raw net.Conn) {
  defer close(c.doneRead)

  buffer := make([]byte, 2e6) // 2MB
  for {
    n, err := raw.Read(buffer)
    if err != nil {
      fmt.Println(err)
      return
    }

    rb.WriteN(buffer, n)
  }
}

func (c *connection) messageLoop(ctx context.Context, rb *ringBuffer, ch <-chan request) {
  defer close(c.doneMessage)

  var (
    buffer = make([]byte, 2e6) // 2MB
    d      = newDecoder(buffer, len(buffer))
  )

  for {
    select {
    case <-ctx.Done():
      return
    default:
      // ok
    }

    // read the header
    rb.ReadN(buffer, 4)
    d.Reset(4)
    v, _ := d.Int32()
    size := int(v)

    // read the payload
    rb.ReadN(buffer, size)
    d.Reset(size)

    var resp ResponseHeader
    if err := (&resp).decode(d, 1); err != nil {
      fmt.Println(err)
      continue
    }

    c.readLock.Lock()
    req, ok := c.requests[resp.CorrelationId]
    delete(c.requests, resp.CorrelationId)
    c.readLock.Unlock()

    if ok {
      req.reply <- req.decode(d)
    }
  }
}

type encodeFunc func(e *encoder, correlationID int32)
type decodeFunc func(d *decoder) error

func (c *connection) write(encode encodeFunc, decode decodeFunc) error {
  correlationID := atomic.AddInt32(&c.id, 1)
  req := request{
    decode: decode,
    reply:  make(chan error, 1),
  }

  c.readLock.Lock()
  c.requests[correlationID] = req
  c.readLock.Unlock()

  c.writeLock.Lock()
  encode(c.encoder, correlationID)
  err := c.encoder.Flush()
  c.writeLock.Unlock()

  if err != nil {
    return err
  }

  return <-req.reply
}

func (c *connection) Close() error {
  c.cancel()
  <-c.doneMessage
  <-c.doneRead
  return c.err
}